Для представления системы проката используются два класса — ApplianceRenting и DVDRenting. Причем оба
реализуют интерфейс Visitable через абстрактный класс Renting, инкапсулирующий длительность проката.
Метод accept() призван рассчитать стоимость обслуживания в зависимости от способов и условий проката.
Способы и условия могут быть стандартными, льготными и штрафными. Возможно появление новых условий. Классы,
реализующие интерфейс Visitor, представляют конкретные алгоритмы расчета для каждого сочетания предлагаемой
услуги и способа ее приобретения.

Если реализация методов accept() во всех классах иерархии будет одинаковой, то нельзя прибегать к услугам
наследования методов и убирать реализацию из подклассов. При вызове метода accept() суперкласса экземпляр,
передаваемый в метод visit(), также будет экземпляром суперкласса, тогда как необходимо передавать экземпляр
класса, вызывающего метод.

Применение шаблона позволяет избавить иерархию Element от насыщения большим количеством логического функционала
или сложной конфигурации.

При определении новых подклассов-наследников Visitor желательно добавлять функциональность ко всем классам
иерархии. Однако существует проблема: переопределить придется метод visit() для каждого типа в иерархии.
Чтобы этого избежать, можно по умолчанию определить класс AbstractVisitor и все тела его методов visit()
оставлять пустыми.

Шаблон хорошо работает, если иерархия классов типа Element остается неизменной. Если добавляются новые подклассы,
то обычно это ведет к изменению в классах типа Visitor, причем довольно значительных.